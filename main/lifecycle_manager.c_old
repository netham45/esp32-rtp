#include "lifecycle_manager.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/queue.h"
#include "freertos/event_groups.h"
#include "esp_log.h"
#include "global.h"
#include "wifi/wifi_manager.h"
#include "web/web_server.h"
#include "mdns/mdns_service.h"
#include "ntp/ntp_client.h"
#include "config/config_manager.h"
#include "sender/network_out.h"
#include "mdns/mdns_discovery.h"
#include "receiver/network_in.h"
#include "receiver/audio_out.h"
#include "receiver/buffer.h"
#include "ota/ota_manager.h"
#ifdef IS_SPDIF
#include "spdif_in.h"
#endif
#ifdef IS_USB
#include "sender/usb_in.h"
#endif
#include "receiver/usb_out.h"
#include "receiver/spdif_out.h"
#include "esp_wifi.h"
#include "esp_pm.h"
#include "nvs_flash.h"
#include "esp_sleep.h"
#include "bq25895/bq25895_integration.h"
#include "pairing/pairing_manager.h"


#define LIFECYCLE_EVENT_QUEUE_SIZE 10

// Import the network activity event group from esp32_scream.c
EventGroupHandle_t s_network_activity_event_group = NULL;

static QueueHandle_t s_lifecycle_event_queue = NULL;
static lifecycle_state_t s_current_state = LIFECYCLE_STATE_INITIALIZING;

// Task for monitoring network activity during silence sleep mode
static TaskHandle_t network_monitor_task_handle = NULL;
static volatile uint32_t packet_counter = 0;
static volatile bool monitoring_active = false;
static volatile TickType_t last_packet_time = 0;

// Cached values for sleep monitoring intervals (thread-safe local copies)
static volatile uint32_t cached_silence_threshold_ms = SILENCE_THRESHOLD_MS;
static volatile uint32_t cached_network_check_interval_ms = NETWORK_CHECK_INTERVAL_MS;
static volatile uint8_t cached_activity_threshold_packets = ACTIVITY_THRESHOLD_PACKETS;
static volatile uint16_t cached_silence_amplitude_threshold = SILENCE_AMPLITUDE_THRESHOLD;
static volatile uint32_t cached_network_inactivity_timeout_ms = NETWORK_INACTIVITY_TIMEOUT_MS;

// Forward declarations from audio.c for the silence tracking variables
// TODO: These should be replaced with a proper API
extern bool is_silent;
extern uint32_t silence_duration_ms;
extern TickType_t last_audio_time;


// Forward declarations for mode start/stop functions
static void start_mode_sender_usb(void);
static void stop_mode_sender_usb(void);
static void start_mode_sender_spdif(void);
static void stop_mode_sender_spdif(void);
static void start_mode_receiver_usb(void);
static void stop_mode_receiver_usb(void);
static void start_mode_receiver_spdif(void);
static void stop_mode_receiver_spdif(void);

// Forward declarations for state handlers
static void handle_state_initializing(lifecycle_event_t event);
static void handle_state_hw_init(lifecycle_event_t event);
static void handle_state_starting_services(lifecycle_event_t event);
static void handle_state_awaiting_mode_config(lifecycle_event_t event);
static void handle_state_mode_sender_usb(lifecycle_event_t event);
static void handle_state_mode_sender_spdif(lifecycle_event_t event);
static void handle_state_mode_receiver_usb(lifecycle_event_t event);
static void handle_state_mode_receiver_spdif(lifecycle_event_t event);
static void handle_state_sleeping(lifecycle_event_t event);
static void handle_state_error(lifecycle_event_t event);
static void handle_state_pairing(lifecycle_event_t event);
static void enter_silence_sleep_mode(void);
static void exit_silence_sleep_mode(void);

// Forward declaration
static void set_state(lifecycle_state_t new_state);
static void evaluate_and_transition(void);
static esp_err_t reconfigure_sample_rate(uint32_t new_rate);
static bool handle_configuration_changed(void);
static esp_err_t buffer_size_reconfigure(void);
static esp_err_t spdif_pin_reconfigure(uint8_t new_pin);

// External functions from audio_out.c for playback control
extern void stop_playback(void);
extern void resume_playback(void);

static void handle_state_entry(lifecycle_state_t state) {
    ESP_LOGI(TAG, "LIFECYCLE: Entering state %d", state);
    switch (state) {
        case LIFECYCLE_STATE_HW_INIT: {
            // Initialize NVS
            esp_err_t ret = nvs_flash_init();
            if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) {
                ESP_ERROR_CHECK(nvs_flash_erase());
                ret = nvs_flash_init();
            }
            ESP_ERROR_CHECK(ret);

            // Initialize configuration manager
            ESP_LOGI(TAG, "Initializing configuration manager");
            ESP_ERROR_CHECK(config_manager_init());

            // Initialize OTA manager
            ESP_LOGI(TAG, "Initializing OTA manager");
            esp_err_t ota_err = ota_manager_init(NULL);  // Use default config
            if (ota_err != ESP_OK) {
                ESP_LOGE(TAG, "Failed to initialize OTA manager: %s", esp_err_to_name(ota_err));
                // Non-critical, continue
            } else {
                ESP_LOGI(TAG, "OTA manager initialized successfully");
            }

            // Initialize BQ25895 Battery Charger
            ESP_LOGI(TAG, "Initializing BQ25895 battery charger");
            esp_err_t bq_err = bq25895_integration_init();
            if (bq_err != ESP_OK) {
                ESP_LOGE(TAG, "Failed to initialize BQ25895: %s", esp_err_to_name(bq_err));
                // Non-critical, continue
            } else {
                ESP_LOGI(TAG, "BQ25895 initialized successfully");
            }

            // Power management configuration
            #if CONFIG_PM_ENABLE
            ESP_LOGI(TAG, "Configuring power management (reduced CPU clock)");
            #if CONFIG_IDF_TARGET_ESP32
            esp_pm_config_esp32_t pm_config = {
                .max_freq_mhz = 80,
                .min_freq_mhz = 40,
            #if CONFIG_FREERTOS_USE_TICKLESS_IDLE
                .light_sleep_enable = true
            #else
                .light_sleep_enable = false
            #endif
            };
            #elif CONFIG_IDF_TARGET_ESP32S3
            esp_pm_config_esp32s3_t pm_config = {
                .max_freq_mhz = 80,
                .min_freq_mhz = 40,
            #if CONFIG_FREERTOS_USE_TICKLESS_IDLE
                .light_sleep_enable = true
            #else
                .light_sleep_enable = false
            #endif
            };
            #endif
            esp_err_t err = esp_pm_configure(&pm_config);
            if (err == ESP_ERR_NOT_SUPPORTED) {
                ESP_LOGW(TAG, "Power management not supported or not enabled in menuconfig");
            } else {
                ESP_ERROR_CHECK(err);
            }
            #else
            ESP_LOGW(TAG, "Power management not enabled in menuconfig");
            #endif

            app_config_t *config = config_manager_get_config();
            
            // Log configuration at initialization
            ESP_LOGI(TAG, "========== CONFIGURATION AT HW_INIT ==========");
            ESP_LOGI(TAG, "Build configuration: %s",
                #ifdef IS_USB
                    "IS_USB"
                #elif defined(IS_SPDIF)
                    "IS_SPDIF"
                #else
                    "UNDEFINED"
                #endif
            );
            ESP_LOGI(TAG, "device_mode: %d", config->device_mode);
            ESP_LOGI(TAG, "sample_rate: %d", config->sample_rate);
            ESP_LOGI(TAG, "spdif_data_pin: %d", config->spdif_data_pin);
            ESP_LOGI(TAG, "===============================================");

            // If in sender mode, skip DAC detection
            if (config->device_mode == MODE_SENDER_SPDIF) {
                ESP_LOGI(TAG, "S/PDIF sender mode configured, proceeding to start services");
                set_state(LIFECYCLE_STATE_STARTING_SERVICES);
                break;
            }

            #ifdef IS_USB
            // LAZY USB INITIALIZATION: Skip DAC detection to save memory
            // USB host will be initialized only when actually needed in USB receiver mode
            // This saves ~30KB of heap memory for buffer allocation
            
            if (config->device_mode == MODE_SENDER_USB) {
                ESP_LOGI(TAG, "USB sender mode configured, skipping DAC detection");
            } else if (config->device_mode == MODE_RECEIVER_USB) {
                ESP_LOGI(TAG, "USB receiver mode configured, deferring USB initialization to mode entry");
                // USB will be initialized when entering LIFECYCLE_STATE_MODE_RECEIVER_USB
            } else {
                ESP_LOGI(TAG, "Non-USB mode configured, no USB initialization needed");
            }
            
            // Note: Deep sleep for DAC detection is disabled with lazy initialization
            // If deep sleep behavior is still desired, implement a lightweight USB detection
            // method that doesn't require full USB host initialization
            #else
            ESP_LOGI(TAG, "Not a USB build, proceeding to start services");
            #endif

            // Proceed to starting services
            set_state(LIFECYCLE_STATE_STARTING_SERVICES);
            break;
        }
        case LIFECYCLE_STATE_STARTING_SERVICES: {
            #ifdef IS_SPDIF
            app_config_t *config = config_manager_get_config();
            if (config->device_mode == MODE_SENDER_SPDIF) {
                ESP_LOGI(TAG, "Initializing S/PDIF receiver with pin %d", config->spdif_data_pin);
                spdif_receiver_init(6, NULL); // Use hardcoded pin from original implementation
            }
            #endif
            
            // Initialize WiFi manager
            ESP_LOGI(TAG, "Initializing WiFi manager...");
            ESP_ERROR_CHECK(wifi_manager_init());
            
            // Try to connect to the strongest network first
            ESP_LOGI(TAG, "Attempting to connect to strongest WiFi network...");
            esp_err_t ret = wifi_manager_connect_to_strongest();
            
            // If connecting to strongest network fails, fall back to normal behavior:
            // 1. Connect using stored credentials if available
            // 2. Start AP mode with captive portal if no credentials are stored
            if (ret != ESP_OK) {
                ESP_LOGI(TAG, "Could not connect to strongest network, falling back to stored credentials or AP mode");
                ESP_ERROR_CHECK(wifi_manager_start());
            }
            
            // Start the web server (works in both AP mode and STA mode)
            ESP_LOGI(TAG, "Starting web server for configuration...");
            web_server_start();

            
            set_state(LIFECYCLE_STATE_AWAITING_MODE_CONFIG);
            break;
        }
        case LIFECYCLE_STATE_AWAITING_MODE_CONFIG: {
            // Check current WiFi state
            wifi_manager_state_t wifi_state = wifi_manager_get_state();
            ESP_LOGI(TAG, "Entering AWAITING_MODE_CONFIG, WiFi state: %d", wifi_state);
            
            if (wifi_state == WIFI_MANAGER_STATE_CONNECTED) {
                ESP_LOGI(TAG, "WiFi is connected, evaluating mode configuration");
                evaluate_and_transition();
            } else if (wifi_state == WIFI_MANAGER_STATE_AP_MODE) {
                ESP_LOGI(TAG, "WiFi is in AP mode, waiting for configuration via web portal");
                // Stay in this state until WiFi is configured
            } else {
                ESP_LOGI(TAG, "WiFi state: %d, waiting for connection or configuration", wifi_state);
            }
            break;
        }
        case LIFECYCLE_STATE_MODE_SENDER_USB:
            start_mode_sender_usb();
            break;
        case LIFECYCLE_STATE_MODE_SENDER_SPDIF:
            start_mode_sender_spdif();
            break;
        case LIFECYCLE_STATE_MODE_RECEIVER_USB:
            start_mode_receiver_usb();
            break;
        case LIFECYCLE_STATE_MODE_RECEIVER_SPDIF:
            start_mode_receiver_spdif();
            break;
        case LIFECYCLE_STATE_SLEEPING:
            enter_silence_sleep_mode();
            break;
        case LIFECYCLE_STATE_PAIRING: {
            ESP_LOGI(TAG, "Starting pairing mode");
            esp_err_t ret = pairing_manager_start();
            if (ret != ESP_OK) {
                ESP_LOGE(TAG, "Failed to start pairing mode: %s", esp_err_to_name(ret));
                // Return to previous state
                evaluate_and_transition();
            }
            break;
        }
        default:
            // No entry action for other states yet
            break;
    }
}

static void handle_state_exit(lifecycle_state_t state) {
    ESP_LOGI(TAG, "LIFECYCLE: Exiting state %d", state);
    switch (state) {
        case LIFECYCLE_STATE_MODE_SENDER_USB:
            stop_mode_sender_usb();
            break;
        case LIFECYCLE_STATE_MODE_SENDER_SPDIF:
            stop_mode_sender_spdif();
            break;
        case LIFECYCLE_STATE_MODE_RECEIVER_USB:
            stop_mode_receiver_usb();
            break;
        case LIFECYCLE_STATE_MODE_RECEIVER_SPDIF:
            stop_mode_receiver_spdif();
            break;
        case LIFECYCLE_STATE_SLEEPING:
            exit_silence_sleep_mode();
            break;
        case LIFECYCLE_STATE_PAIRING:
            ESP_LOGI(TAG, "Exiting pairing mode");
            // Pairing manager cleanup is handled internally
            break;
        default:
            // No exit action for other states yet
            break;
    }
}

static void set_state(lifecycle_state_t new_state) {
    if (s_current_state == new_state) {
        return;
    }
    handle_state_exit(s_current_state);
    ESP_LOGI(TAG, "LIFECYCLE: Transitioning from state %d to %d", s_current_state, new_state);
    s_current_state = new_state;
    handle_state_entry(s_current_state);
}

static void lifecycle_manager_task(void *pvParameters) {
    ESP_LOGI(TAG, "Lifecycle manager task started.");
    
    // Initial state transition
    set_state(LIFECYCLE_STATE_HW_INIT);

    while (1) {
        lifecycle_event_t event;
        if (xQueueReceive(s_lifecycle_event_queue, &event, portMAX_DELAY) == pdPASS) {
            ESP_LOGI(TAG, "LIFECYCLE: Received event %d in state %d", event, s_current_state);
            switch (s_current_state) {
                case LIFECYCLE_STATE_INITIALIZING:
                    handle_state_initializing(event);
                    break;
                case LIFECYCLE_STATE_HW_INIT:
                    handle_state_hw_init(event);
                    break;
                case LIFECYCLE_STATE_STARTING_SERVICES:
                    handle_state_starting_services(event);
                    break;
                case LIFECYCLE_STATE_AWAITING_MODE_CONFIG:
                    handle_state_awaiting_mode_config(event);
                    break;
                case LIFECYCLE_STATE_MODE_SENDER_USB:
                    handle_state_mode_sender_usb(event);
                    break;
                case LIFECYCLE_STATE_MODE_SENDER_SPDIF:
                    handle_state_mode_sender_spdif(event);
                    break;
                case LIFECYCLE_STATE_MODE_RECEIVER_USB:
                    handle_state_mode_receiver_usb(event);
                    break;
                case LIFECYCLE_STATE_MODE_RECEIVER_SPDIF:
                    handle_state_mode_receiver_spdif(event);
                    break;
                case LIFECYCLE_STATE_SLEEPING:
                    handle_state_sleeping(event);
                    break;
                case LIFECYCLE_STATE_ERROR:
                    handle_state_error(event);
                    break;
                case LIFECYCLE_STATE_PAIRING:
                    handle_state_pairing(event);
                    break;
            }
        }
    }
}

esp_err_t lifecycle_manager_init(void) {
    // Create the network activity event group if it doesn't exist
    if (s_network_activity_event_group == NULL) {
        s_network_activity_event_group = xEventGroupCreate();
        if (s_network_activity_event_group == NULL) {
            ESP_LOGE(TAG, "Failed to create network activity event group");
            return ESP_FAIL;
        }
        ESP_LOGI(TAG, "Created network activity event group");
    }

    s_lifecycle_event_queue = xQueueCreate(LIFECYCLE_EVENT_QUEUE_SIZE, sizeof(lifecycle_event_t));
    if (s_lifecycle_event_queue == NULL) {
        ESP_LOGE(TAG, "Failed to create lifecycle event queue");
        return ESP_FAIL;
    }

    BaseType_t ret = xTaskCreatePinnedToCore(lifecycle_manager_task, "lifecycle_mgr", 4096, NULL, 1, NULL, 0);
    if (ret != pdPASS) {
        ESP_LOGE(TAG, "Failed to create lifecycle manager task");
        return ESP_FAIL;
    }

    return ESP_OK;
}

esp_err_t lifecycle_manager_post_event(lifecycle_event_t event) {
    if (s_lifecycle_event_queue == NULL) {
        ESP_LOGE(TAG, "Lifecycle event queue not initialized");
        return ESP_FAIL;
    }

    if (xQueueSend(s_lifecycle_event_queue, &event, 0) != pdPASS) {
        ESP_LOGE(TAG, "Failed to post event to lifecycle queue");
        return ESP_FAIL;
    }

    return ESP_OK;
}

esp_err_t lifecycle_manager_change_sample_rate(uint32_t new_rate) {
    app_config_t *config = config_manager_get_config();
    if (config->sample_rate != new_rate) {
        ESP_LOGI(TAG, "Sample rate changed from %d to %d. Reconfiguring.", config->sample_rate, new_rate);
        config->sample_rate = new_rate;
        esp_err_t ret = config_manager_save_config();
        if (ret != ESP_OK) {
            ESP_LOGE(TAG, "Failed to save new sample rate to config");
            return ret;
        }
        
        // Check if we're in an active receiver mode
        if (s_current_state == LIFECYCLE_STATE_MODE_RECEIVER_USB ||
            s_current_state == LIFECYCLE_STATE_MODE_RECEIVER_SPDIF) {
            ESP_LOGI(TAG, "Active receiver mode detected, applying sample rate change immediately");
            
            // Try to reconfigure without restart
            ret = reconfigure_sample_rate(new_rate);
            if (ret == ESP_OK) {
                ESP_LOGI(TAG, "Sample rate changed successfully without restart");
                return ESP_OK;
            } else {
                ESP_LOGW(TAG, "Immediate reconfiguration failed, falling back to restart");
                // Fall through to post event for restart
            }
        }
        
        // If not in active mode or reconfiguration failed, post event for restart
        ESP_LOGI(TAG, "Posting sample rate change event for restart");
        return lifecycle_manager_post_event(LIFECYCLE_EVENT_SAMPLE_RATE_CHANGE);
    }
    return ESP_OK;
}

void lifecycle_manager_report_network_activity(void) {
    if (monitoring_active) {
        packet_counter++;
        last_packet_time = xTaskGetTickCount();
        // Signal the network monitor task that a packet has been received
        if (s_network_activity_event_group) {
            xEventGroupSetBits(s_network_activity_event_group, NETWORK_PACKET_RECEIVED_BIT);
        }
    }
}

// --- State Handler Implementations ---

static void handle_state_initializing(lifecycle_event_t event) {
    ESP_LOGI(TAG, "LIFECYCLE: Handling state: INITIALIZING");
}

static void handle_state_hw_init(lifecycle_event_t event) {
    ESP_LOGI(TAG, "LIFECYCLE: Handling state: HW_INIT");
    // Only process on specific events, not all events
    if (event != LIFECYCLE_EVENT_WIFI_CONNECTED &&
        event != LIFECYCLE_EVENT_USB_DAC_CONNECTED &&
        event != LIFECYCLE_EVENT_USB_DAC_DISCONNECTED &&
        event != LIFECYCLE_EVENT_CONFIGURATION_CHANGED) {
        // Ignore other events while in HW_INIT
        return;
    }
}

static void handle_state_starting_services(lifecycle_event_t event) {
    ESP_LOGI(TAG, "LIFECYCLE: Handling state: STARTING_SERVICES");
    // Entry actions are handled in handle_state_entry,
    // this function will handle events received *while* in this state.
}

static void evaluate_and_transition(void) {
    app_config_t *config = config_manager_get_config();
    
    // Log the current configuration
    ESP_LOGI(TAG, "========== CURRENT CONFIGURATION ==========");
    ESP_LOGI(TAG, "Build type: %s",
        #ifdef IS_USB
            "USB"
        #elif defined(IS_SPDIF)
            "S/PDIF"
        #else
            "UNKNOWN"
        #endif
    );
    ESP_LOGI(TAG, "Device mode: %d", config->device_mode);
    ESP_LOGI(TAG, "Sample rate: %d Hz", config->sample_rate);
    ESP_LOGI(TAG, "Bit depth: %d bits", config->bit_depth);
    ESP_LOGI(TAG, "Volume: %.2f", config->volume);
    ESP_LOGI(TAG, "Sender destination IP: %s", config->sender_destination_ip);
    ESP_LOGI(TAG, "Sender destination port: %d", config->sender_destination_port);
    ESP_LOGI(TAG, "S/PDIF data pin: %d", config->spdif_data_pin);
    ESP_LOGI(TAG, "==========================================");
    
    // Check WiFi state first
    wifi_manager_state_t wifi_state = wifi_manager_get_state();
    ESP_LOGI(TAG, "Current WiFi state: %d", wifi_state);
    
    // Only transition to operational modes if WiFi is connected or we're in sender mode
    if (wifi_state != WIFI_MANAGER_STATE_CONNECTED &&
        (config->device_mode == MODE_RECEIVER_USB || config->device_mode == MODE_RECEIVER_SPDIF)) {
        ESP_LOGI(TAG, "WiFi not connected and in receiver mode, staying in AWAITING_MODE_CONFIG");
        return;
    }

    // Determine which state to enter based on device mode
    switch (config->device_mode) {
        case MODE_SENDER_USB:
            ESP_LOGI(TAG, "Transitioning to USB sender mode");
            set_state(LIFECYCLE_STATE_MODE_SENDER_USB);
            break;
        case MODE_SENDER_SPDIF:
            ESP_LOGI(TAG, "Transitioning to S/PDIF sender mode");
            set_state(LIFECYCLE_STATE_MODE_SENDER_SPDIF);
            break;
        case MODE_RECEIVER_USB:
            ESP_LOGI(TAG, "Transitioning to USB receiver mode");
            set_state(LIFECYCLE_STATE_MODE_RECEIVER_USB);
            break;
        case MODE_RECEIVER_SPDIF:
            ESP_LOGI(TAG, "Transitioning to S/PDIF receiver mode");
            set_state(LIFECYCLE_STATE_MODE_RECEIVER_SPDIF);
            break;
    }
}

static void handle_state_awaiting_mode_config(lifecycle_event_t event) {
    ESP_LOGI(TAG, "LIFECYCLE: Handling state: AWAITING_MODE_CONFIG");
    switch (event) {
        case LIFECYCLE_EVENT_WIFI_CONNECTED:
            ESP_LOGI(TAG, "WiFi connected, starting NTP.");
            // mDNS is started by wifi_manager during initialization (works in all modes)
            initialize_ntp_client();
            evaluate_and_transition();
            break;
        case LIFECYCLE_EVENT_WIFI_DISCONNECTED:
            ESP_LOGI(TAG, "WiFi disconnected.");
            // mDNS continues running (managed by wifi_manager)
            break;
        case LIFECYCLE_EVENT_CONFIGURATION_CHANGED: {
            ESP_LOGI(TAG, "Configuration changed, re-evaluating mode.");
            
            // Check if we now have WiFi credentials
            if (!wifi_manager_has_credentials()) {
                ESP_LOGI(TAG, "No WiFi credentials, staying in AP mode");
                // Stay in AP mode for configuration
            } else {
                ESP_LOGI(TAG, "WiFi credentials available, attempting connection");
                // Try to connect with new credentials
                wifi_manager_state_t state = wifi_manager_get_state();
                if (state == WIFI_MANAGER_STATE_AP_MODE || state == WIFI_MANAGER_STATE_CONNECTION_FAILED) {
                    // Don't restart everything - just reconnect with new credentials
                    // wifi_manager_connect will handle the reconnection properly
                    char ssid[WIFI_SSID_MAX_LENGTH + 1];
                    char password[WIFI_PASSWORD_MAX_LENGTH + 1];
                    if (wifi_manager_get_credentials(ssid, sizeof(ssid), password, sizeof(password)) == ESP_OK) {
                        wifi_manager_connect(ssid, password);
                    }
                }
            }
            evaluate_and_transition();
            break;
        }
        case LIFECYCLE_EVENT_START_PAIRING:
            ESP_LOGI(TAG, "Starting pairing mode from awaiting config state");
            set_state(LIFECYCLE_STATE_PAIRING);
            break;
        default:
            break;
    }
}

static void handle_state_mode_sender_usb(lifecycle_event_t event) {
    ESP_LOGI(TAG, "LIFECYCLE: Handling state: MODE_SENDER_USB");
    if (event == LIFECYCLE_EVENT_CONFIGURATION_CHANGED) {
        // Use unified configuration handler to apply immediate changes
        bool restart_required = handle_configuration_changed();
        
        // Only re-evaluate/restart if necessary
        if (restart_required) {
            ESP_LOGI(TAG, "Configuration changes require restart, re-evaluating state");
            evaluate_and_transition();
        } else {
            ESP_LOGI(TAG, "Configuration changes applied immediately without restart");
        }
    } else if (event == LIFECYCLE_EVENT_START_PAIRING) {
        set_state(LIFECYCLE_STATE_PAIRING);
    }
}

static void handle_state_mode_sender_spdif(lifecycle_event_t event) {
    ESP_LOGI(TAG, "LIFECYCLE: Handling state: MODE_SENDER_SPDIF");
    if (event == LIFECYCLE_EVENT_CONFIGURATION_CHANGED) {
        // Use unified configuration handler to apply immediate changes
        bool restart_required = handle_configuration_changed();
        
        // Only re-evaluate/restart if necessary
        if (restart_required) {
            ESP_LOGI(TAG, "Configuration changes require restart, re-evaluating state");
            evaluate_and_transition();
        } else {
            ESP_LOGI(TAG, "Configuration changes applied immediately without restart");
        }
    } else if (event == LIFECYCLE_EVENT_START_PAIRING) {
        set_state(LIFECYCLE_STATE_PAIRING);
    }
}

static void handle_state_mode_receiver_usb(lifecycle_event_t event) {
    ESP_LOGI(TAG, "LIFECYCLE: Handling state: MODE_RECEIVER_USB");
    if (event == LIFECYCLE_EVENT_ENTER_SLEEP) {
        set_state(LIFECYCLE_STATE_SLEEPING);
    } else if (event == LIFECYCLE_EVENT_CONFIGURATION_CHANGED) {
        // Use unified configuration handler to apply immediate changes
        bool restart_required = handle_configuration_changed();
        
        // Only re-evaluate/restart if necessary
        if (restart_required) {
            ESP_LOGI(TAG, "Configuration changes require restart, re-evaluating state");
            evaluate_and_transition();
        } else {
            ESP_LOGI(TAG, "Configuration changes applied immediately without restart");
        }
    } else if (event == LIFECYCLE_EVENT_START_PAIRING) {
        set_state(LIFECYCLE_STATE_PAIRING);
    } else if (event == LIFECYCLE_EVENT_SAMPLE_RATE_CHANGE) {
        ESP_LOGI(TAG, "Received sample rate change event, re-evaluating mode.");
        evaluate_and_transition();
    }
}

static void handle_state_mode_receiver_spdif(lifecycle_event_t event) {
    ESP_LOGI(TAG, "LIFECYCLE: Handling state: MODE_RECEIVER_SPDIF");
    if (event == LIFECYCLE_EVENT_ENTER_SLEEP) {
        set_state(LIFECYCLE_STATE_SLEEPING);
    } else if (event == LIFECYCLE_EVENT_CONFIGURATION_CHANGED) {
        // Use unified configuration handler to apply immediate changes
        bool restart_required = handle_configuration_changed();
        
        // Only re-evaluate/restart if necessary
        if (restart_required) {
            ESP_LOGI(TAG, "Configuration changes require restart, re-evaluating state");
            evaluate_and_transition();
        } else {
            ESP_LOGI(TAG, "Configuration changes applied immediately without restart");
        }
    } else if (event == LIFECYCLE_EVENT_START_PAIRING) {
        set_state(LIFECYCLE_STATE_PAIRING);
    } else if (event == LIFECYCLE_EVENT_SAMPLE_RATE_CHANGE) {
        ESP_LOGI(TAG, "Received sample rate change event, re-evaluating mode.");
        evaluate_and_transition();
    }
}

static void handle_state_sleeping(lifecycle_event_t event) {
    ESP_LOGI(TAG, "LIFECYCLE: Handling state: SLEEPING");
    if (event == LIFECYCLE_EVENT_WAKE_UP) {
        set_state(LIFECYCLE_STATE_AWAITING_MODE_CONFIG);
    }
}

static void handle_state_error(lifecycle_event_t event) {
    ESP_LOGI(TAG, "LIFECYCLE: Handling state: ERROR");
}

static void handle_state_pairing(lifecycle_event_t event) {
    ESP_LOGI(TAG, "LIFECYCLE: Handling state: PAIRING");
    switch (event) {
        case LIFECYCLE_EVENT_PAIRING_COMPLETE:
            ESP_LOGI(TAG, "Pairing complete, returning to previous mode");
            evaluate_and_transition();
            break;
        case LIFECYCLE_EVENT_CANCEL_PAIRING:
            ESP_LOGI(TAG, "Pairing cancelled by user");
            evaluate_and_transition();
            break;
        case LIFECYCLE_EVENT_WIFI_DISCONNECTED:
            ESP_LOGW(TAG, "WiFi disconnected during pairing, aborting");
            evaluate_and_transition();
            break;
        default:
            break;
    }
}

// --- Mode Start/Stop Implementations ---

static void start_mode_sender_usb(void) {
    ESP_LOGI(TAG, "Starting USB sender mode...");
    #ifdef IS_USB
    // Initialize network sender first (reads from pcm_buffer)
    esp_err_t ret = rtp_sender_init();
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Failed to initialize RTP sender: %s", esp_err_to_name(ret));
        return;
    }
    
    // Initialize USB input (receives audio from host, writes to pcm_buffer)
    ESP_LOGI(TAG, "Initializing USB audio input (USB speaker device)");
    ret = usb_in_init(NULL);
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Failed to initialize USB input: %s", esp_err_to_name(ret));
        return;
    }
    
    // Start USB input to begin receiving audio from host
    ESP_LOGI(TAG, "Starting USB audio input");
    ret = usb_in_start();
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Failed to start USB input: %s", esp_err_to_name(ret));
        usb_in_deinit();
        return;
    }
    
    // Start network sender to transmit over RTP
    ESP_LOGI(TAG, "Starting RTP network sender");
    ret = rtp_sender_start();
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Failed to start RTP sender: %s", esp_err_to_name(ret));
        usb_in_stop();
        usb_in_deinit();
        return;
    }
    
    ESP_LOGI(TAG, "USB sender mode started successfully (USB audio -> RTP)");
    #else
    ESP_LOGW(TAG, "USB support not enabled in build");
    #endif
}

static void stop_mode_sender_usb(void) {
    ESP_LOGI(TAG, "Stopping USB sender mode...");
    #ifdef IS_USB
    // Stop RTP sender first
    esp_err_t ret = rtp_sender_stop();
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Failed to stop RTP sender: %s", esp_err_to_name(ret));
    }
    
    // Stop USB input
    ret = usb_in_stop();
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Failed to stop USB input: %s", esp_err_to_name(ret));
    }
    
    // Deinitialize USB input
    usb_in_deinit();
    
    ESP_LOGI(TAG, "USB sender mode stopped");
    #endif
}
static void start_mode_sender_spdif(void) {
    ESP_LOGI(TAG, "Starting S/PDIF sender mode...");
    #ifdef IS_SPDIF
    ESP_LOGI(TAG, "Initializing Scream sender");
    esp_err_t ret = rtp_sender_init();
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Failed to initialize Scream sender: %s", esp_err_to_name(ret));
        return;
    }
    ESP_LOGI(TAG, "Starting S/PDIF receiver");
    ret = spdif_receiver_start();
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Failed to start S/PDIF receiver: %s", esp_err_to_name(ret));
        return;
    }
    ESP_LOGI(TAG, "Starting Scream sender");
    ret = rtp_sender_start();
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Failed to start Scream sender: %s", esp_err_to_name(ret));
        spdif_receiver_stop();
        return;
    }
    ESP_LOGI(TAG, "S/PDIF sender mode started successfully");
    #else
    ESP_LOGW(TAG, "S/PDIF support not enabled in build");
    #endif
}
static void stop_mode_sender_spdif(void) {
    ESP_LOGI(TAG, "Stopping S/PDIF sender mode...");
    #ifdef IS_SPDIF
    esp_err_t ret = rtp_sender_stop();
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Failed to stop Scream sender: %s", esp_err_to_name(ret));
    }
    ret = spdif_receiver_stop();
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Failed to stop S/PDIF receiver: %s", esp_err_to_name(ret));
    }
    #endif
}
static void start_mode_receiver_usb(void) {
    ESP_LOGI(TAG, "Starting USB receiver mode...");
    #ifdef IS_USB
    // Setup audio output first
    setup_audio();

    // Setup buffer for network->USB streaming
    setup_buffer();

    // Setup network receiver
    network_init();

    // Initialize USB host subsystem
    esp_err_t ret = usb_out_init();
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Failed to initialize USB host: %s", esp_err_to_name(ret));
        return;
    }

    // Start USB host for DAC output
    ret = usb_out_start();
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Failed to start USB host: %s", esp_err_to_name(ret));
        return;
    }
    ESP_LOGI(TAG, "USB receiver mode started successfully");
    #else
    ESP_LOGW(TAG, "USB support not enabled in build");
    #endif
}
static void stop_mode_receiver_usb(void) {
    ESP_LOGI(TAG, "Stopping USB receiver mode...");
    #ifdef IS_USB
    esp_err_t ret = usb_out_stop();
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Failed to stop USB host: %s", esp_err_to_name(ret));
    }

    ret = usb_out_deinit();
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Failed to deinitialize USB host: %s", esp_err_to_name(ret));
    }

    // TODO: Stop network and audio tasks properly
    // For now, these don't have clean stop functions
    #endif
}
static void start_mode_receiver_spdif(void) {
    ESP_LOGI(TAG, "Starting S/PDIF receiver mode...");
    uint32_t sample_rate = lifecycle_get_sample_rate();
    uint8_t spdif_data_pin = lifecycle_get_spdif_data_pin();

    // Setup buffer for network->S/PDIF streaming
    setup_buffer();

    setup_audio();

        
    ESP_LOGI(TAG, "Initializing SPDIF output with pin %d and sample rate %" PRIu32,
        spdif_data_pin, sample_rate);
        
    esp_err_t err = spdif_init(sample_rate);
    if (err == ESP_OK) {
        ESP_LOGI(TAG, "SPDIF initialized successfully");
    } else {
        ESP_LOGE(TAG, "Failed to initialize SPDIF: %s", esp_err_to_name(err));
        ESP_LOGW(TAG, "Audio output will not be available. Please check the SPDIF pin configuration in the web UI.");
    }

    
    // Setup network receiver
    network_init();
    
    ESP_LOGI(TAG, "S/PDIF receiver mode started successfully");
}

static void stop_mode_receiver_spdif(void) {
    ESP_LOGI(TAG, "Stopping S/PDIF receiver mode...");
    #ifdef IS_SPDIF
    // TODO: Stop network, buffer, and S/PDIF output properly
    // For now, these don't have clean stop functions
    #endif
}

static void network_monitor_task(void *params) {
    ESP_LOGI(TAG, "Network monitor task started");

    // Initialize the last packet time
    last_packet_time = xTaskGetTickCount();

    while (true) {
        if (monitoring_active) {
            // Use cached interval value for thread-safe access
            uint32_t check_interval = cached_network_check_interval_ms;
            
            // Wait for a packet notification OR timeout
            EventBits_t bits = xEventGroupWaitBits(
                s_network_activity_event_group,   // The event group being tested.
                NETWORK_PACKET_RECEIVED_BIT,      // The bits within the event group to wait for.
                pdTRUE,                           // NETWORK_PACKET_RECEIVED_BIT should be cleared before returning.
                pdFALSE,                          // Don't wait for all bits, any bit will do (we only have one).
                pdMS_TO_TICKS(check_interval)     // Use cached value for wait time
            );

            // Check if still monitoring after the wait (could have been disabled by exit_silence_sleep_mode)
            if (!monitoring_active) {
                continue; // Exit loop iteration if monitoring was stopped during wait
            }

            TickType_t current_time = xTaskGetTickCount();
            TickType_t time_since_last_packet = (current_time - last_packet_time) * portTICK_PERIOD_MS;

            // Get cached threshold values for thread-safe access
            uint8_t activity_threshold = cached_activity_threshold_packets;
            uint32_t inactivity_timeout = cached_network_inactivity_timeout_ms;

            // Did we receive a packet notification?
            if (bits & NETWORK_PACKET_RECEIVED_BIT) {
                ESP_LOGD(TAG, "Monitor: Packet received event bit set.");
                // packet_counter and last_packet_time are updated in network.c when the bit is set
                // Check if the activity threshold is met
                if (packet_counter >= activity_threshold) {
                    ESP_LOGI(TAG, "Network activity threshold met (%" PRIu32 " packets >= %d), exiting sleep mode",
                            packet_counter, activity_threshold);
                    lifecycle_manager_post_event(LIFECYCLE_EVENT_WAKE_UP);
                } else {
                    ESP_LOGD(TAG, "Monitor: Packet count %" PRIu32 " < threshold %d", packet_counter, activity_threshold);
                }
            } else {
                // No packet notification bit set, timeout occurred. Check for inactivity timeout.
                ESP_LOGD(TAG, "Monitor: Wait timeout. Packets=%" PRIu32 ", time_since_last=%lu ms", packet_counter, (unsigned long)time_since_last_packet);
                if (time_since_last_packet >= inactivity_timeout) {
                    ESP_LOGI(TAG, "Network inactivity timeout reached (%lu ms >= %lu ms), maintaining sleep mode",
                            (unsigned long)time_since_last_packet, (unsigned long)inactivity_timeout);
                    // Update timestamp to prevent continuous logging of the same timeout event
                    // Note: last_packet_time is only updated here on timeout, or in network.c on packet arrival.
                    last_packet_time = current_time;
                }
            }
            // The loop continues, waiting again with xEventGroupWaitBits which includes the delay

        } else {
            // When not actively monitoring, suspend the task to save CPU
            ESP_LOGD(TAG, "Monitoring inactive, suspending monitor task.");
            // Clear any pending event bits before suspending
            if (s_network_activity_event_group) {
                xEventGroupClearBits(s_network_activity_event_group, NETWORK_PACKET_RECEIVED_BIT);
            }
            vTaskSuspend(NULL);
            // --- Task resumes here when vTaskResume is called (in enter_silence_sleep_mode) ---
            ESP_LOGD(TAG, "Monitor task resumed.");
            // Reset state when resuming
            last_packet_time = xTaskGetTickCount();
            packet_counter = 0; // Reset packet counter when monitoring starts/resumes
            // Clear event bits again on resume just in case
            if (s_network_activity_event_group) {
                xEventGroupClearBits(s_network_activity_event_group, NETWORK_PACKET_RECEIVED_BIT);
            }
        }
    }
}

void enter_silence_sleep_mode(void) {
    app_config_t *config = config_manager_get_config();
    if (config->device_mode != MODE_RECEIVER_USB && config->device_mode != MODE_RECEIVER_SPDIF) {
        ESP_LOGI(TAG, "Device is in sender mode, silence sleep is disabled");
        return;
    }
    
    ESP_LOGI(TAG, "Entering silence sleep mode");
    
    // Make sure event group exists
    if (s_network_activity_event_group == NULL) {
        ESP_LOGE(TAG, "Network activity event group not initialized, cannot enter sleep mode");
        return;
    }
    
    // Update cached values from config for thread-safe access in monitor task
    cached_silence_threshold_ms = config->silence_threshold_ms;
    cached_network_check_interval_ms = config->network_check_interval_ms;
    cached_activity_threshold_packets = config->activity_threshold_packets;
    cached_silence_amplitude_threshold = config->silence_amplitude_threshold;
    cached_network_inactivity_timeout_ms = config->network_inactivity_timeout_ms;
    
    ESP_LOGI(TAG, "Sleep monitoring configured: silence_threshold=%lums, check_interval=%lums, "
             "activity_threshold=%d packets, amplitude_threshold=%d, inactivity_timeout=%lums",
             cached_silence_threshold_ms, cached_network_check_interval_ms,
             cached_activity_threshold_packets, cached_silence_amplitude_threshold,
             cached_network_inactivity_timeout_ms);
    
    // Configure WiFi for max power saving
    esp_err_t ret = esp_wifi_set_ps(WIFI_PS_MAX_MODEM);
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Failed to set WiFi power save mode: %s", esp_err_to_name(ret));
    }

    // Suppress WiFi warnings
    esp_log_level_set("wifi", ESP_LOG_ERROR);

    // Create network monitoring task if it doesn't exist yet
    if (network_monitor_task_handle == NULL) {
        BaseType_t task_ret = xTaskCreatePinnedToCore(
            network_monitor_task,
            "network_monitor",
            4096,
            NULL,
            1,  // Low priority
            &network_monitor_task_handle,
            0   // Core 0
        );
        if (task_ret != pdTRUE) {
            ESP_LOGE(TAG, "Failed to create network monitor task");
            return;
        }
    }
    
    // Start network monitoring
    monitoring_active = true;
    packet_counter = 0;
    if (eTaskGetState(network_monitor_task_handle) == eSuspended) {
        vTaskResume(network_monitor_task_handle);
    }
    
    ESP_LOGI(TAG, "Entered light sleep mode with network monitoring");
}

void exit_silence_sleep_mode(void) {
    ESP_LOGI(TAG, "Exiting silence sleep mode");
    
    // Stop the network monitoring
    monitoring_active = false;
    
    // Set WiFi back to normal power saving mode
    esp_err_t ret = esp_wifi_set_ps(WIFI_PS_MIN_MODEM);
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Failed to set WiFi normal mode: %s", esp_err_to_name(ret));
    }

    // Reset silence tracking variables to prevent immediate re-entry into sleep mode
    is_silent = false;
    silence_duration_ms = 0;
    last_audio_time = xTaskGetTickCount(); // Reset to current time
    
    ESP_LOGI(TAG, "Resumed normal operation");
}

// --- Configuration Getter Functions ---

uint16_t lifecycle_get_port(void) {
    app_config_t *config = config_manager_get_config();
    return config->port;
}

const char* lifecycle_get_hostname(void) {
    app_config_t *config = config_manager_get_config();
    return config->hostname;
}

uint32_t lifecycle_get_sample_rate(void) {
    app_config_t *config = config_manager_get_config();
    return config->sample_rate;
}

uint8_t lifecycle_get_bit_depth(void) {
    app_config_t *config = config_manager_get_config();
    return config->bit_depth;
}

float lifecycle_get_volume(void) {
    app_config_t *config = config_manager_get_config();
    return config->volume;
}

device_mode_t lifecycle_get_device_mode(void) {
    app_config_t *config = config_manager_get_config();
    return config->device_mode;
}

bool lifecycle_get_enable_usb_sender(void) {
    app_config_t *config = config_manager_get_config();
    return config->device_mode == MODE_SENDER_USB;
}

bool lifecycle_get_enable_spdif_sender(void) {
    app_config_t *config = config_manager_get_config();
    return config->device_mode == MODE_SENDER_SPDIF;
}

const char* lifecycle_get_ap_ssid(void) {
    app_config_t *config = config_manager_get_config();
    return config->ap_ssid;
}

const char* lifecycle_get_ap_password(void) {
    app_config_t *config = config_manager_get_config();
    return config->ap_password;
}

bool lifecycle_get_hide_ap_when_connected(void) {
    app_config_t *config = config_manager_get_config();
    return config->hide_ap_when_connected;
}

const char* lifecycle_get_sender_destination_ip(void) {
    app_config_t *config = config_manager_get_config();
    return config->sender_destination_ip;
}

uint16_t lifecycle_get_sender_destination_port(void) {
    app_config_t *config = config_manager_get_config();
    return config->sender_destination_port;
}

uint8_t lifecycle_get_initial_buffer_size(void) {
    app_config_t *config = config_manager_get_config();
    return 16;
    return config->initial_buffer_size;
}

uint8_t lifecycle_get_max_buffer_size(void) {
    app_config_t *config = config_manager_get_config();
    return 24;
    return config->max_buffer_size;
}

uint8_t lifecycle_get_buffer_grow_step_size(void) {
    app_config_t *config = config_manager_get_config();
    return 2;
    return config->buffer_grow_step_size;
}

uint8_t lifecycle_get_max_grow_size(void) {
    app_config_t *config = config_manager_get_config();
    return 32;
    return config->max_grow_size;
}

uint8_t lifecycle_get_spdif_data_pin(void) {
    app_config_t *config = config_manager_get_config();
    return config->spdif_data_pin;
}

bool lifecycle_get_use_direct_write(void) {
    app_config_t *config = config_manager_get_config();
    return config->use_direct_write;
}

uint32_t lifecycle_get_silence_threshold_ms(void) {
    app_config_t *config = config_manager_get_config();
    return config->silence_threshold_ms;
}

uint32_t lifecycle_get_network_check_interval_ms(void) {
    app_config_t *config = config_manager_get_config();
    return config->network_check_interval_ms;
}

uint8_t lifecycle_get_activity_threshold_packets(void) {
    app_config_t *config = config_manager_get_config();
    return config->activity_threshold_packets;
}

uint16_t lifecycle_get_silence_amplitude_threshold(void) {
    app_config_t *config = config_manager_get_config();
    return config->silence_amplitude_threshold;
}

uint32_t lifecycle_get_network_inactivity_timeout_ms(void) {
    app_config_t *config = config_manager_get_config();
    return config->network_inactivity_timeout_ms;
}

bool lifecycle_get_enable_mdns_discovery(void) {
    app_config_t *config = config_manager_get_config();
    return config->enable_mdns_discovery;
}

uint32_t lifecycle_get_discovery_interval_ms(void) {
    app_config_t *config = config_manager_get_config();
    return config->discovery_interval_ms;
}

bool lifecycle_get_auto_select_best_device(void) {
    app_config_t *config = config_manager_get_config();
    return config->auto_select_best_device;
}

// --- Configuration Setter Functions ---

esp_err_t lifecycle_set_port(uint16_t port) {
    app_config_t *config = config_manager_get_config();
    if (config->port != port) {
        ESP_LOGI(TAG, "Setting port to %d", port);
        uint16_t old_port = config->port;
        config->port = port;
        esp_err_t ret = config_manager_save_setting("port", &port, sizeof(port));
        if (ret == ESP_OK) {
            // If in receiver mode and port changed, restart network
            if (s_current_state == LIFECYCLE_STATE_MODE_RECEIVER_USB ||
                s_current_state == LIFECYCLE_STATE_MODE_RECEIVER_SPDIF) {
                ESP_LOGI(TAG, "Port changed from %d to %d in receiver mode, restarting network", old_port, port);
                network_update_port();
            }
            lifecycle_manager_post_event(LIFECYCLE_EVENT_CONFIGURATION_CHANGED);
        }
        return ret;
    }
    return ESP_OK;
}

esp_err_t lifecycle_set_hostname(const char* hostname) {
    if (!hostname) {
        return ESP_ERR_INVALID_ARG;
    }

    app_config_t *config = config_manager_get_config();
    if (strcmp(config->hostname, hostname) != 0) {
        ESP_LOGI(TAG, "Setting hostname to %s", hostname);
        strncpy(config->hostname, hostname, sizeof(config->hostname) - 1);
        config->hostname[sizeof(config->hostname) - 1] = '\0';
        esp_err_t ret = config_manager_save_setting("hostname", config->hostname, sizeof(config->hostname));
        if (ret == ESP_OK) {
            lifecycle_manager_post_event(LIFECYCLE_EVENT_CONFIGURATION_CHANGED);
        }
        return ret;
    }
    return ESP_OK;
}

esp_err_t lifecycle_set_volume(float volume) {
    if (volume < 0.0f || volume > 1.0f) {
        ESP_LOGE(TAG, "Invalid volume value: %f", volume);
        return ESP_ERR_INVALID_ARG;
    }
    
    app_config_t *config = config_manager_get_config();
    if (config->volume != volume) {
        ESP_LOGI(TAG, "Setting volume to %.2f", volume);
        config->volume = volume;
        esp_err_t ret = config_manager_save_setting("volume", &volume, sizeof(volume));
        if (ret == ESP_OK) {
            // Apply volume change immediately if in receiver USB mode
            #ifdef IS_USB
            if (s_current_state == LIFECYCLE_STATE_MODE_RECEIVER_USB) {
                audio_out_update_volume();
            }
            #endif
            // Post event for notification
            lifecycle_manager_post_event(LIFECYCLE_EVENT_CONFIGURATION_CHANGED);
        }
        return ret;
    }
    return ESP_OK;
}

esp_err_t lifecycle_set_device_mode(device_mode_t mode) {
    app_config_t *config = config_manager_get_config();
    if (config->device_mode != mode) {
        ESP_LOGI(TAG, "Setting device mode to %d", mode);
        config->device_mode = mode;
        esp_err_t ret = config_manager_save_setting("device_mode", &mode, sizeof(mode));
        if (ret == ESP_OK) {
            lifecycle_manager_post_event(LIFECYCLE_EVENT_CONFIGURATION_CHANGED);
        }
        return ret;
    }
    return ESP_OK;
}

esp_err_t lifecycle_set_enable_usb_sender(bool enable) {
    app_config_t *config = config_manager_get_config();
    // When disabling USB sender, default to receiver mode based on build type
    device_mode_t new_mode;
    if (enable) {
        new_mode = MODE_SENDER_USB;
    } else {
        #ifdef IS_USB
        new_mode = MODE_RECEIVER_USB;
        #elif defined(IS_SPDIF)
        new_mode = MODE_RECEIVER_SPDIF;
        #else
        new_mode = MODE_RECEIVER_USB;  // Default fallback
        #endif
    }
    if (config->device_mode != new_mode) {
        ESP_LOGI(TAG, "Setting USB sender enabled to %d (device_mode=%d)", enable, new_mode);
        config->device_mode = new_mode;
        esp_err_t ret = config_manager_save_setting("device_mode", &new_mode, sizeof(new_mode));
        if (ret == ESP_OK) {
            lifecycle_manager_post_event(LIFECYCLE_EVENT_CONFIGURATION_CHANGED);
        }
        return ret;
    }
    return ESP_OK;
}

esp_err_t lifecycle_set_enable_spdif_sender(bool enable) {
    app_config_t *config = config_manager_get_config();
    // When disabling SPDIF sender, default to receiver mode based on build type
    device_mode_t new_mode;
    if (enable) {
        new_mode = MODE_SENDER_SPDIF;
    } else {
        #ifdef IS_USB
        new_mode = MODE_RECEIVER_USB;
        #elif defined(IS_SPDIF)
        new_mode = MODE_RECEIVER_SPDIF;
        #else
        new_mode = MODE_RECEIVER_USB;  // Default fallback
        #endif
    }
    if (config->device_mode != new_mode) {
        ESP_LOGI(TAG, "Setting SPDIF sender enabled to %d (device_mode=%d)", enable, new_mode);
        config->device_mode = new_mode;
        esp_err_t ret = config_manager_save_setting("device_mode", &new_mode, sizeof(new_mode));
        if (ret == ESP_OK) {
            lifecycle_manager_post_event(LIFECYCLE_EVENT_CONFIGURATION_CHANGED);
        }
        return ret;
    }
    return ESP_OK;
}

esp_err_t lifecycle_set_ap_ssid(const char* ssid) {
    if (!ssid) {
        return ESP_ERR_INVALID_ARG;
    }
    
    app_config_t *config = config_manager_get_config();
    if (strcmp(config->ap_ssid, ssid) != 0) {
        ESP_LOGI(TAG, "Setting AP SSID to %s", ssid);
        strncpy(config->ap_ssid, ssid, WIFI_SSID_MAX_LENGTH);
        config->ap_ssid[WIFI_SSID_MAX_LENGTH] = '\0';
        esp_err_t ret = config_manager_save_setting("ap_ssid", config->ap_ssid, sizeof(config->ap_ssid));
        if (ret == ESP_OK) {
            lifecycle_manager_post_event(LIFECYCLE_EVENT_CONFIGURATION_CHANGED);
        }
        return ret;
    }
    return ESP_OK;
}

esp_err_t lifecycle_set_ap_password(const char* password) {
    if (!password) {
        return ESP_ERR_INVALID_ARG;
    }
    
    app_config_t *config = config_manager_get_config();
    if (strcmp(config->ap_password, password) != 0) {
        ESP_LOGI(TAG, "Setting AP password");
        strncpy(config->ap_password, password, WIFI_PASSWORD_MAX_LENGTH);
        config->ap_password[WIFI_PASSWORD_MAX_LENGTH] = '\0';
        esp_err_t ret = config_manager_save_setting("ap_password", config->ap_password, sizeof(config->ap_password));
        if (ret == ESP_OK) {
            lifecycle_manager_post_event(LIFECYCLE_EVENT_CONFIGURATION_CHANGED);
        }
        return ret;
    }
    return ESP_OK;
}

esp_err_t lifecycle_set_hide_ap_when_connected(bool hide) {
    app_config_t *config = config_manager_get_config();
    if (config->hide_ap_when_connected != hide) {
        ESP_LOGI(TAG, "Setting hide_ap_when_connected to %d", hide);
        config->hide_ap_when_connected = hide;
        esp_err_t ret = config_manager_save_setting("hide_ap_when_connected", &hide, sizeof(hide));
        if (ret == ESP_OK) {
            // Apply AP visibility change immediately if connected
            wifi_manager_state_t wifi_state = wifi_manager_get_state();
            if (wifi_state == WIFI_MANAGER_STATE_CONNECTED) {
                if (hide) {
                    ESP_LOGI(TAG, "Hiding AP interface (WiFi is connected)");
                    esp_wifi_set_mode(WIFI_MODE_STA);
                } else {
                    ESP_LOGI(TAG, "Showing AP interface");
                    esp_wifi_set_mode(WIFI_MODE_APSTA);
                }
            }
            lifecycle_manager_post_event(LIFECYCLE_EVENT_CONFIGURATION_CHANGED);
        }
        return ret;
    }
    return ESP_OK;
}

esp_err_t lifecycle_set_sender_destination_ip(const char* ip) {
    if (!ip) {
        return ESP_ERR_INVALID_ARG;
    }
    
    app_config_t *config = config_manager_get_config();
    if (strcmp(config->sender_destination_ip, ip) != 0) {
        ESP_LOGI(TAG, "Setting sender destination IP to %s", ip);
        strncpy(config->sender_destination_ip, ip, 15);
        config->sender_destination_ip[15] = '\0';
        esp_err_t ret = config_manager_save_setting("sender_destination_ip", config->sender_destination_ip,
                                                    sizeof(config->sender_destination_ip));
        if (ret == ESP_OK) {
            // If we're in sender mode, update the destination immediately without restart
            if (s_current_state == LIFECYCLE_STATE_MODE_SENDER_USB ||
                s_current_state == LIFECYCLE_STATE_MODE_SENDER_SPDIF) {
                ESP_LOGI(TAG, "Updating RTP sender destination IP immediately");
                rtp_sender_update_destination();
            }
            lifecycle_manager_post_event(LIFECYCLE_EVENT_CONFIGURATION_CHANGED);
        }
        return ret;
    }
    return ESP_OK;
}

esp_err_t lifecycle_set_sender_destination_port(uint16_t port) {
    app_config_t *config = config_manager_get_config();
    if (config->sender_destination_port != port) {
        ESP_LOGI(TAG, "Setting sender destination port to %d", port);
        config->sender_destination_port = port;
        esp_err_t ret = config_manager_save_setting("sender_destination_port", &port, sizeof(port));
        if (ret == ESP_OK) {
            // If we're in sender mode, update the destination immediately without restart
            if (s_current_state == LIFECYCLE_STATE_MODE_SENDER_USB ||
                s_current_state == LIFECYCLE_STATE_MODE_SENDER_SPDIF) {
                ESP_LOGI(TAG, "Updating RTP sender destination port immediately");
                rtp_sender_update_destination();
            }
            lifecycle_manager_post_event(LIFECYCLE_EVENT_CONFIGURATION_CHANGED);
        }
        return ret;
    }
    return ESP_OK;
}

esp_err_t lifecycle_set_initial_buffer_size(uint8_t size) {
    app_config_t *config = config_manager_get_config();
    if (config->initial_buffer_size != size) {
        ESP_LOGI(TAG, "Setting initial_buffer_size to %d", size);
        config->initial_buffer_size = size;
        esp_err_t ret = config_manager_save_setting("initial_buffer_size", &size, sizeof(size));
        if (ret == ESP_OK) {
            // If in receiver mode, reconfigure buffer immediately
            if (s_current_state == LIFECYCLE_STATE_MODE_RECEIVER_USB ||
                s_current_state == LIFECYCLE_STATE_MODE_RECEIVER_SPDIF) {
                ESP_LOGI(TAG, "Updating buffer configuration immediately");
                buffer_size_reconfigure();
            }
            lifecycle_manager_post_event(LIFECYCLE_EVENT_CONFIGURATION_CHANGED);
        }
        return ret;
    }
    return ESP_OK;
}

esp_err_t lifecycle_set_max_buffer_size(uint8_t size) {
    app_config_t *config = config_manager_get_config();
    if (config->max_buffer_size != size) {
        ESP_LOGI(TAG, "Setting max_buffer_size to %d", size);
        config->max_buffer_size = size;
        esp_err_t ret = config_manager_save_setting("max_buffer_size", &size, sizeof(size));
        if (ret == ESP_OK) {
            // If in receiver mode, reconfigure buffer immediately
            if (s_current_state == LIFECYCLE_STATE_MODE_RECEIVER_USB ||
                s_current_state == LIFECYCLE_STATE_MODE_RECEIVER_SPDIF) {
                ESP_LOGI(TAG, "Updating buffer configuration immediately");
                buffer_size_reconfigure();
            }
            lifecycle_manager_post_event(LIFECYCLE_EVENT_CONFIGURATION_CHANGED);
        }
        return ret;
    }
    return ESP_OK;
}

esp_err_t lifecycle_set_buffer_grow_step_size(uint8_t size) {
    app_config_t *config = config_manager_get_config();
    if (config->buffer_grow_step_size != size) {
        ESP_LOGI(TAG, "Setting buffer_grow_step_size to %d", size);
        config->buffer_grow_step_size = size;
        esp_err_t ret = config_manager_save_setting("buffer_grow_step_size", &size, sizeof(size));
        if (ret == ESP_OK) {
            // If in receiver mode, reconfigure buffer immediately
            if (s_current_state == LIFECYCLE_STATE_MODE_RECEIVER_USB ||
                s_current_state == LIFECYCLE_STATE_MODE_RECEIVER_SPDIF) {
                ESP_LOGI(TAG, "Updating buffer configuration immediately");
                buffer_size_reconfigure();
            }
            lifecycle_manager_post_event(LIFECYCLE_EVENT_CONFIGURATION_CHANGED);
        }
        return ret;
    }
    return ESP_OK;
}

esp_err_t lifecycle_set_max_grow_size(uint8_t size) {
    app_config_t *config = config_manager_get_config();
    if (config->max_grow_size != size) {
        ESP_LOGI(TAG, "Setting max_grow_size to %d", size);
        config->max_grow_size = size;
        esp_err_t ret = config_manager_save_setting("max_grow_size", &size, sizeof(size));
        if (ret == ESP_OK) {
            // If in receiver mode, reconfigure buffer immediately
            if (s_current_state == LIFECYCLE_STATE_MODE_RECEIVER_USB ||
                s_current_state == LIFECYCLE_STATE_MODE_RECEIVER_SPDIF) {
                ESP_LOGI(TAG, "Updating buffer configuration immediately");
                buffer_size_reconfigure();
            }
            lifecycle_manager_post_event(LIFECYCLE_EVENT_CONFIGURATION_CHANGED);
        }
        return ret;
    }
    return ESP_OK;
}

esp_err_t lifecycle_set_spdif_data_pin(uint8_t pin) {
    if (pin > 39) { // ESP32 GPIO range
        ESP_LOGE(TAG, "Invalid SPDIF data pin: %d", pin);
        return ESP_ERR_INVALID_ARG;
    }
    
    app_config_t *config = config_manager_get_config();
    if (config->spdif_data_pin != pin) {
        ESP_LOGI(TAG, "Setting SPDIF data pin to %d", pin);
        uint8_t old_pin = config->spdif_data_pin;
        config->spdif_data_pin = pin;
        esp_err_t ret = config_manager_save_setting("spdif_data_pin", &pin, sizeof(pin));
        if (ret == ESP_OK) {
            // Check if we're currently in a SPDIF mode
            if (s_current_state == LIFECYCLE_STATE_MODE_RECEIVER_SPDIF ||
                s_current_state == LIFECYCLE_STATE_MODE_SENDER_SPDIF) {
                ESP_LOGI(TAG, "SPDIF mode active, applying pin change immediately");
                
                // Try to reconfigure without restart
                ret = spdif_pin_reconfigure(pin);
                if (ret == ESP_OK) {
                    ESP_LOGI(TAG, "SPDIF pin changed from %d to %d successfully without restart", old_pin, pin);
                    // No need to post configuration changed event as we handled it
                } else {
                    ESP_LOGW(TAG, "Immediate pin reconfiguration failed, will require restart");
                    // Post event for restart
                    lifecycle_manager_post_event(LIFECYCLE_EVENT_CONFIGURATION_CHANGED);
                }
            } else {
                // Not in SPDIF mode, just post the event for future use
                ESP_LOGI(TAG, "SPDIF pin configuration saved, will be used on next SPDIF mode activation");
                lifecycle_manager_post_event(LIFECYCLE_EVENT_CONFIGURATION_CHANGED);
            }
        }
        return ret;
    }
    return ESP_OK;
}

esp_err_t lifecycle_set_silence_threshold_ms(uint32_t threshold_ms) {
    app_config_t *config = config_manager_get_config();
    if (config->silence_threshold_ms != threshold_ms) {
        ESP_LOGI(TAG, "Setting silence_threshold_ms to %lu", threshold_ms);
        config->silence_threshold_ms = threshold_ms;
        esp_err_t ret = config_manager_save_setting("silence_threshold_ms", &threshold_ms, sizeof(threshold_ms));
        if (ret == ESP_OK) {
            // Update cached value immediately if monitoring is active
            if (monitoring_active) {
                cached_silence_threshold_ms = threshold_ms;
                ESP_LOGI(TAG, "Updated active silence threshold to %lu ms", threshold_ms);
            }
            lifecycle_manager_post_event(LIFECYCLE_EVENT_CONFIGURATION_CHANGED);
        }
        return ret;
    }
    return ESP_OK;
}

/**
 * Reconfigure sample rate for active receiver modes without restart
 * This function temporarily pauses audio output, reconfigures the appropriate
 * subsystem (USB or SPDIF), and resumes playback.
 */
static esp_err_t reconfigure_sample_rate(uint32_t new_rate) {
    ESP_LOGI(TAG, "Reconfiguring sample rate to %lu Hz without restart", new_rate);
    
    // Check if we're in a receiver mode
    if (s_current_state != LIFECYCLE_STATE_MODE_RECEIVER_USB &&
        s_current_state != LIFECYCLE_STATE_MODE_RECEIVER_SPDIF) {
        ESP_LOGW(TAG, "Sample rate reconfiguration only available in receiver modes");
        return ESP_ERR_INVALID_STATE;
    }
    
    esp_err_t ret = ESP_OK;
    
    // Temporarily pause audio output
    ESP_LOGI(TAG, "Pausing audio output for reconfiguration");
    stop_playback();
    
    // Small delay to ensure audio has stopped
    vTaskDelay(pdMS_TO_TICKS(100));
    
    // Reconfigure based on current mode
    if (s_current_state == LIFECYCLE_STATE_MODE_RECEIVER_USB) {
        #ifdef IS_USB
        ESP_LOGI(TAG, "Reconfiguring USB audio output for sample rate %lu Hz", new_rate);
        // Note: USB audio typically handles sample rate changes automatically
        // If a specific reconfiguration function exists, call it here
        // For now, we rely on the USB audio subsystem to adapt
        ESP_LOGI(TAG, "USB audio will adapt to new sample rate on resume");
        #else
        ESP_LOGW(TAG, "USB support not enabled in build");
        ret = ESP_ERR_NOT_SUPPORTED;
        #endif
    } else if (s_current_state == LIFECYCLE_STATE_MODE_RECEIVER_SPDIF) {
        #ifdef IS_SPDIF
        ESP_LOGI(TAG, "Reconfiguring SPDIF output for sample rate %lu Hz", new_rate);
        ret = spdif_set_sample_rates((int)new_rate);
        if (ret != ESP_OK) {
            ESP_LOGE(TAG, "Failed to reconfigure SPDIF sample rate: 0x%x", ret);
        } else {
            ESP_LOGI(TAG, "SPDIF sample rate reconfigured successfully");
        }
        #else
        ESP_LOGW(TAG, "SPDIF support not enabled in build");
        ret = ESP_ERR_NOT_SUPPORTED;
        #endif
    }
    
    // Resume audio output
    ESP_LOGI(TAG, "Resuming audio output after reconfiguration");
    resume_playback();
    
    if (ret == ESP_OK) {
        ESP_LOGI(TAG, "Sample rate reconfiguration completed successfully");
    } else {
        ESP_LOGE(TAG, "Sample rate reconfiguration failed: 0x%x", ret);
    }
    
    return ret;
}

/**
 * Reconfigure SPDIF pin for active SPDIF modes without restart
 * This function handles runtime reconfiguration of the SPDIF data pin
 * for both sender and receiver modes.
 */
static esp_err_t spdif_pin_reconfigure(uint8_t new_pin) {
    ESP_LOGI(TAG, "Reconfiguring SPDIF data pin to GPIO %d", new_pin);
    
    // Check if we're in a SPDIF mode
    if (s_current_state != LIFECYCLE_STATE_MODE_RECEIVER_SPDIF &&
        s_current_state != LIFECYCLE_STATE_MODE_SENDER_SPDIF) {
        ESP_LOGW(TAG, "SPDIF pin reconfiguration only available in SPDIF modes");
        return ESP_ERR_INVALID_STATE;
    }
    
    esp_err_t ret = ESP_OK;
    
    #ifdef IS_SPDIF
    if (s_current_state == LIFECYCLE_STATE_MODE_RECEIVER_SPDIF) {
        ESP_LOGI(TAG, "Reconfiguring SPDIF receiver output pin");
        
        // Temporarily pause audio output
        ESP_LOGI(TAG, "Pausing audio output for pin reconfiguration");
        stop_playback();
        
        // Small delay to ensure audio has stopped
        vTaskDelay(pdMS_TO_TICKS(100));
        
        // Get current sample rate from config
        app_config_t *config = config_manager_get_config();
        
        // Reinitialize SPDIF with new pin
        ESP_LOGI(TAG, "Reinitializing SPDIF output with GPIO %d", new_pin);
        ret = spdif_init(lifecycle_get_sample_rate());
        if (ret != ESP_OK) {
            ESP_LOGE(TAG, "Failed to reinitialize SPDIF output: 0x%x", ret);
        } else {
            // Reconfigure sample rate after reinit
            ret = spdif_set_sample_rates((int)config->sample_rate);
            if (ret != ESP_OK) {
                ESP_LOGE(TAG, "Failed to restore SPDIF sample rate: 0x%x", ret);
            }
        }
        
        // Resume audio output
        ESP_LOGI(TAG, "Resuming audio output after pin reconfiguration");
        resume_playback();
        
    } else if (s_current_state == LIFECYCLE_STATE_MODE_SENDER_SPDIF) {
        ESP_LOGI(TAG, "Reconfiguring SPDIF sender input pin");
        
        // Stop SPDIF receiver
        ESP_LOGI(TAG, "Stopping SPDIF receiver");
        ret = spdif_receiver_stop();
        if (ret != ESP_OK) {
            ESP_LOGE(TAG, "Failed to stop SPDIF receiver: 0x%x", ret);
        }
        
        // Deinitialize SPDIF receiver
        ESP_LOGI(TAG, "Deinitializing SPDIF receiver");
        spdif_receiver_deinit();
        
        // Small delay to ensure cleanup
        vTaskDelay(pdMS_TO_TICKS(100));
        
        // Reinitialize with new pin
        ESP_LOGI(TAG, "Reinitializing SPDIF receiver with GPIO %d", new_pin);
        ret = spdif_receiver_init(new_pin, NULL);
        if (ret != ESP_OK) {
            ESP_LOGE(TAG, "Failed to reinitialize SPDIF receiver: 0x%x", ret);
        } else {
            // Restart SPDIF receiver
            ESP_LOGI(TAG, "Restarting SPDIF receiver");
            ret = spdif_receiver_start();
            if (ret != ESP_OK) {
                ESP_LOGE(TAG, "Failed to restart SPDIF receiver: 0x%x", ret);
            }
        }
    }
    #else
    ESP_LOGW(TAG, "SPDIF support not enabled in build");
    ret = ESP_ERR_NOT_SUPPORTED;
    #endif
    
    if (ret == ESP_OK) {
        ESP_LOGI(TAG, "SPDIF pin reconfiguration completed successfully");
    } else {
        ESP_LOGE(TAG, "SPDIF pin reconfiguration failed: 0x%x", ret);
    }
    
    return ret;
}

/**
 * Reconfigure buffer sizes for active receiver modes without restart
 * This function handles runtime reconfiguration of buffer parameters including
 * initial buffer size and max buffer size. For significant changes like
 * max_buffer_size, this requires reallocating the buffer.
 */
static esp_err_t buffer_size_reconfigure(void) {
    ESP_LOGI(TAG, "Reconfiguring buffer sizes without restart");
    
    // Check if we're in a receiver mode
    if (s_current_state != LIFECYCLE_STATE_MODE_RECEIVER_USB &&
        s_current_state != LIFECYCLE_STATE_MODE_RECEIVER_SPDIF) {
        ESP_LOGW(TAG, "Buffer size reconfiguration only available in receiver modes");
        return ESP_ERR_INVALID_STATE;
    }
    
    esp_err_t ret = ESP_OK;
    
    // Get current configuration
    app_config_t *config = config_manager_get_config();
    
    ESP_LOGI(TAG, "Reconfiguring buffer with parameters:");
    ESP_LOGI(TAG, "  initial_buffer_size: %d", config->initial_buffer_size);
    ESP_LOGI(TAG, "  max_buffer_size: %d", config->max_buffer_size);
    ESP_LOGI(TAG, "  buffer_grow_step_size: %d", config->buffer_grow_step_size);
    ESP_LOGI(TAG, "  max_grow_size: %d", config->max_grow_size);
    
    // Temporarily pause audio output
    ESP_LOGI(TAG, "Pausing audio output for buffer reconfiguration");
    stop_playback();
    
    // Small delay to ensure audio has stopped
    vTaskDelay(pdMS_TO_TICKS(100));
    
    // Empty the current buffer
    ESP_LOGI(TAG, "Emptying buffer before reconfiguration");
    empty_buffer();
    
    // For max_buffer_size changes, we need to reallocate the entire buffer
    // This is a more complex operation that requires freeing and reallocating
    // For now, we'll log a warning that this requires a restart
    ESP_LOGW(TAG, "Note: Changing max_buffer_size requires a system restart for full effect");
    ESP_LOGI(TAG, "Buffer growth parameters will be updated immediately");
    
    // Update buffer growth parameters (this is safe without reallocation)
    ret = buffer_update_growth_params();
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Failed to update buffer growth parameters: 0x%x", ret);
    }
    
    // Resume audio output
    ESP_LOGI(TAG, "Resuming audio output after buffer reconfiguration");
    resume_playback();
    
    if (ret == ESP_OK) {
        ESP_LOGI(TAG, "Buffer reconfiguration completed successfully");
    } else {
        ESP_LOGE(TAG, "Buffer reconfiguration failed: 0x%x", ret);
    }
    
    return ret;
}
/**
 * Unified configuration change handler
 * Compares current configuration with previous configuration and applies changes
 * that can be handled immediately without requiring a system restart.
 * 
 * @return true if restart is required for some changes, false if all changes were applied immediately
 */
static bool handle_configuration_changed(void) {
    ESP_LOGI(TAG, "Checking for configuration changes that can be applied immediately");
    
    // Static variable to track previous configuration
    static app_config_t previous_config = {0};
    static bool first_call = true;
    
    // Get current configuration
    app_config_t *current_config = config_manager_get_config();
    
    // If this is the first call, just save the current config as previous
    if (first_call) {
        memcpy(&previous_config, current_config, sizeof(app_config_t));
        first_call = false;
        return false;  // No changes on first call
    }
    
    bool restart_required = false;
    bool any_changes = false;
    
    // Check for port changes
    if (current_config->port != previous_config.port) {
        ESP_LOGI(TAG, "Port changed from %d to %d", previous_config.port, current_config->port);
        any_changes = true;
        
        // If in receiver mode, update port immediately
        if (s_current_state == LIFECYCLE_STATE_MODE_RECEIVER_USB ||
            s_current_state == LIFECYCLE_STATE_MODE_RECEIVER_SPDIF) {
            ESP_LOGI(TAG, "Applying port change immediately");
            network_update_port();
        }
    }
    
    // Check for hostname changes
    if (strcmp(current_config->hostname, previous_config.hostname) != 0) {
        ESP_LOGI(TAG, "Hostname changed from %s to %s", previous_config.hostname, current_config->hostname);
        any_changes = true;
        
        // Update mDNS hostname immediately
        ESP_LOGI(TAG, "Updating mDNS hostname immediately");
        mdns_service_update_hostname();
    }
    
    // Check for sender destination changes
    if (strcmp(current_config->sender_destination_ip, previous_config.sender_destination_ip) != 0 ||
        current_config->sender_destination_port != previous_config.sender_destination_port) {
        ESP_LOGI(TAG, "Sender destination changed: %s:%d -> %s:%d", 
                previous_config.sender_destination_ip, previous_config.sender_destination_port,
                current_config->sender_destination_ip, current_config->sender_destination_port);
        any_changes = true;
        
        // If in sender mode, update destination immediately
        if (s_current_state == LIFECYCLE_STATE_MODE_SENDER_USB ||
            s_current_state == LIFECYCLE_STATE_MODE_SENDER_SPDIF) {
            ESP_LOGI(TAG, "Updating sender destination immediately");
            rtp_sender_update_destination();
        }
    }
    
    // Check for buffer parameter changes
    if (current_config->initial_buffer_size != previous_config.initial_buffer_size ||
        current_config->max_buffer_size != previous_config.max_buffer_size ||
        current_config->buffer_grow_step_size != previous_config.buffer_grow_step_size ||
        current_config->max_grow_size != previous_config.max_grow_size) {
        ESP_LOGI(TAG, "Buffer parameters changed");
        any_changes = true;
        
        // If in receiver mode, reconfigure buffer
        if (s_current_state == LIFECYCLE_STATE_MODE_RECEIVER_USB ||
            s_current_state == LIFECYCLE_STATE_MODE_RECEIVER_SPDIF) {
            ESP_LOGI(TAG, "Reconfiguring buffer parameters immediately");
            esp_err_t ret = buffer_size_reconfigure();
            if (ret != ESP_OK) {
                ESP_LOGW(TAG, "Buffer reconfiguration failed, restart may be needed");
                restart_required = true;
            }
        }
    }
    
    // Check for sample rate changes
    if (current_config->sample_rate != previous_config.sample_rate) {
        ESP_LOGI(TAG, "Sample rate changed from %lu to %lu", 
                previous_config.sample_rate, current_config->sample_rate);
        any_changes = true;
        
        // Try to reconfigure sample rate immediately in receiver modes
        if (s_current_state == LIFECYCLE_STATE_MODE_RECEIVER_USB ||
            s_current_state == LIFECYCLE_STATE_MODE_RECEIVER_SPDIF) {
            ESP_LOGI(TAG, "Attempting immediate sample rate reconfiguration");
            esp_err_t ret = reconfigure_sample_rate(current_config->sample_rate);
            if (ret != ESP_OK) {
                ESP_LOGW(TAG, "Sample rate reconfiguration failed, restart required");
                restart_required = true;
            }
        } else {
            // In sender modes, sample rate change requires restart
            restart_required = true;
        }
    }
    
    // Check for SPDIF pin changes
    if (current_config->spdif_data_pin != previous_config.spdif_data_pin) {
        ESP_LOGI(TAG, "SPDIF pin changed from %d to %d", 
                previous_config.spdif_data_pin, current_config->spdif_data_pin);
        any_changes = true;
        
        // If in SPDIF mode, reconfigure pin
        if (s_current_state == LIFECYCLE_STATE_MODE_RECEIVER_SPDIF ||
            s_current_state == LIFECYCLE_STATE_MODE_SENDER_SPDIF) {
            ESP_LOGI(TAG, "Reconfiguring SPDIF pin immediately");
            esp_err_t ret = spdif_pin_reconfigure(current_config->spdif_data_pin);
            if (ret != ESP_OK) {
                ESP_LOGW(TAG, "SPDIF pin reconfiguration failed, restart required");
                restart_required = true;
            }
        }
    }
    
    // Check for volume changes
    if (current_config->volume != previous_config.volume) {
        ESP_LOGI(TAG, "Volume changed from %.2f to %.2f", 
                previous_config.volume, current_config->volume);
        any_changes = true;
        
        // Apply volume change immediately in receiver USB mode
        #ifdef IS_USB
        if (s_current_state == LIFECYCLE_STATE_MODE_RECEIVER_USB) {
            ESP_LOGI(TAG, "Applying volume change immediately");
            audio_out_update_volume();
        }
        #endif
    }
    
    // Check for direct write mode changes
    if (current_config->use_direct_write != previous_config.use_direct_write) {
        ESP_LOGI(TAG, "Direct write mode changed from %d to %d", 
                previous_config.use_direct_write, current_config->use_direct_write);
        any_changes = true;
        
    }
    
    // Check for sleep monitoring parameter changes
    if (current_config->silence_threshold_ms != previous_config.silence_threshold_ms ||
        current_config->network_check_interval_ms != previous_config.network_check_interval_ms ||
        current_config->activity_threshold_packets != previous_config.activity_threshold_packets ||
        current_config->silence_amplitude_threshold != previous_config.silence_amplitude_threshold ||
        current_config->network_inactivity_timeout_ms != previous_config.network_inactivity_timeout_ms) {
        ESP_LOGI(TAG, "Sleep monitoring parameters changed");
        any_changes = true;
        
        // Update cached values if monitoring is active
        if (monitoring_active) {
            ESP_LOGI(TAG, "Updating active sleep monitoring parameters");
            cached_silence_threshold_ms = current_config->silence_threshold_ms;
            cached_network_check_interval_ms = current_config->network_check_interval_ms;
            cached_activity_threshold_packets = current_config->activity_threshold_packets;
            cached_silence_amplitude_threshold = current_config->silence_amplitude_threshold;
            cached_network_inactivity_timeout_ms = current_config->network_inactivity_timeout_ms;
        }
    }
    
    // Check for device mode changes - these always require restart
    if (current_config->device_mode != previous_config.device_mode) {
        ESP_LOGI(TAG, "Device mode changed from %d to %d - restart required", 
                previous_config.device_mode, current_config->device_mode);
        any_changes = true;
        restart_required = true;
    }
    
    // Check for AP visibility setting changes
    if (current_config->hide_ap_when_connected != previous_config.hide_ap_when_connected) {
        ESP_LOGI(TAG, "AP visibility setting changed from %d to %d",
                previous_config.hide_ap_when_connected, current_config->hide_ap_when_connected);
        any_changes = true;
        
        // Apply AP visibility change immediately if WiFi is connected
        wifi_manager_state_t wifi_state = wifi_manager_get_state();
        if (wifi_state == WIFI_MANAGER_STATE_CONNECTED) {
            if (current_config->hide_ap_when_connected) {
                ESP_LOGI(TAG, "Hiding AP interface immediately");
                esp_wifi_set_mode(WIFI_MODE_STA);
            } else {
                ESP_LOGI(TAG, "Showing AP interface immediately");
                esp_wifi_set_mode(WIFI_MODE_APSTA);
            }
        }
    }
    
    // Update previous configuration with current values
    if (any_changes) {
        ESP_LOGI(TAG, "Configuration changes detected, updating previous config cache");
        memcpy(&previous_config, current_config, sizeof(app_config_t));
    }
    
    if (!any_changes) {
        ESP_LOGD(TAG, "No configuration changes detected");
    }
    
    return restart_required;
}


esp_err_t lifecycle_set_network_check_interval_ms(uint32_t interval_ms) {
    app_config_t *config = config_manager_get_config();
    if (config->network_check_interval_ms != interval_ms) {
        ESP_LOGI(TAG, "Setting network_check_interval_ms to %lu", interval_ms);
        config->network_check_interval_ms = interval_ms;
        esp_err_t ret = config_manager_save_setting("network_check_interval_ms", &interval_ms, sizeof(interval_ms));
        if (ret == ESP_OK) {
            // Update cached value immediately if monitoring is active
            if (monitoring_active) {
                cached_network_check_interval_ms = interval_ms;
                ESP_LOGI(TAG, "Updated active network check interval to %lu ms", interval_ms);
            }
            lifecycle_manager_post_event(LIFECYCLE_EVENT_CONFIGURATION_CHANGED);
        }
        return ret;
    }
    return ESP_OK;
}

esp_err_t lifecycle_set_activity_threshold_packets(uint8_t packets) {
    app_config_t *config = config_manager_get_config();
    if (config->activity_threshold_packets != packets) {
        ESP_LOGI(TAG, "Setting activity_threshold_packets to %d", packets);
        config->activity_threshold_packets = packets;
        esp_err_t ret = config_manager_save_setting("activity_threshold_packets", &packets, sizeof(packets));
        if (ret == ESP_OK) {
            // Update cached value immediately if monitoring is active
            if (monitoring_active) {
                cached_activity_threshold_packets = packets;
                ESP_LOGI(TAG, "Updated active activity threshold to %d packets", packets);
            }
            lifecycle_manager_post_event(LIFECYCLE_EVENT_CONFIGURATION_CHANGED);
        }
        return ret;
    }
    return ESP_OK;
}

esp_err_t lifecycle_set_silence_amplitude_threshold(uint16_t threshold) {
    app_config_t *config = config_manager_get_config();
    if (config->silence_amplitude_threshold != threshold) {
        ESP_LOGI(TAG, "Setting silence_amplitude_threshold to %d", threshold);
        config->silence_amplitude_threshold = threshold;
        esp_err_t ret = config_manager_save_setting("silence_amplitude_threshold", &threshold, sizeof(threshold));
        if (ret == ESP_OK) {
            // Update cached value immediately if monitoring is active
            if (monitoring_active) {
                cached_silence_amplitude_threshold = threshold;
                ESP_LOGI(TAG, "Updated active silence amplitude threshold to %d", threshold);
            }
            lifecycle_manager_post_event(LIFECYCLE_EVENT_CONFIGURATION_CHANGED);
        }
        return ret;
    }
    return ESP_OK;
}

esp_err_t lifecycle_set_network_inactivity_timeout_ms(uint32_t timeout_ms) {
    app_config_t *config = config_manager_get_config();
    if (config->network_inactivity_timeout_ms != timeout_ms) {
        ESP_LOGI(TAG, "Setting network_inactivity_timeout_ms to %lu", timeout_ms);
        config->network_inactivity_timeout_ms = timeout_ms;
        esp_err_t ret = config_manager_save_setting("network_inactivity_timeout_ms", &timeout_ms, sizeof(timeout_ms));
        if (ret == ESP_OK) {
            // Update cached value immediately if monitoring is active
            if (monitoring_active) {
                cached_network_inactivity_timeout_ms = timeout_ms;
                ESP_LOGI(TAG, "Updated active network inactivity timeout to %lu ms", timeout_ms);
            }
            lifecycle_manager_post_event(LIFECYCLE_EVENT_CONFIGURATION_CHANGED);
        }
        return ret;
    }
    return ESP_OK;
}

esp_err_t lifecycle_set_enable_mdns_discovery(bool enable) {
    app_config_t *config = config_manager_get_config();
    if (config->enable_mdns_discovery != enable) {
        ESP_LOGI(TAG, "Setting enable_mdns_discovery to %d", enable);
        config->enable_mdns_discovery = enable;
        esp_err_t ret = config_manager_save_setting("enable_mdns_discovery", &enable, sizeof(enable));
        if (ret == ESP_OK) {
            // Start or stop mDNS discovery based on new setting
            if (enable) {
                ESP_LOGI(TAG, "Enabling mDNS discovery");
                mdns_discovery_start();
            } else {
                ESP_LOGI(TAG, "Disabling mDNS discovery");
                mdns_discovery_stop();
            }
            lifecycle_manager_post_event(LIFECYCLE_EVENT_CONFIGURATION_CHANGED);
        }
        return ret;
    }
    return ESP_OK;
}

esp_err_t lifecycle_set_discovery_interval_ms(uint32_t interval_ms) {
    app_config_t *config = config_manager_get_config();
    if (config->discovery_interval_ms != interval_ms) {
        ESP_LOGI(TAG, "Setting discovery_interval_ms to %lu", interval_ms);
        config->discovery_interval_ms = interval_ms;
        esp_err_t ret = config_manager_save_setting("discovery_interval_ms", &interval_ms, sizeof(interval_ms));
        if (ret == ESP_OK) {
            lifecycle_manager_post_event(LIFECYCLE_EVENT_CONFIGURATION_CHANGED);
        }
        return ret;
    }
    return ESP_OK;
}

esp_err_t lifecycle_set_auto_select_best_device(bool enable) {
    app_config_t *config = config_manager_get_config();
    if (config->auto_select_best_device != enable) {
        ESP_LOGI(TAG, "Setting auto_select_best_device to %d", enable);
        config->auto_select_best_device = enable;
        esp_err_t ret = config_manager_save_setting("auto_select_best_device", &enable, sizeof(enable));
        if (ret == ESP_OK) {
            lifecycle_manager_post_event(LIFECYCLE_EVENT_CONFIGURATION_CHANGED);
        }
        return ret;
    }
    return ESP_OK;
}

esp_err_t lifecycle_update_config_batch(const lifecycle_config_update_t* updates) {
    if (!updates) {
        return ESP_ERR_INVALID_ARG;
    }
    
    app_config_t *config = config_manager_get_config();
    bool config_changed = false;
    
    // Update each field if requested
    if (updates->update_port && config->port != updates->port) {
        ESP_LOGI(TAG, "Batch update: port = %d", updates->port);
        config->port = updates->port;
        config_changed = true;
    }

    if (updates->update_hostname && updates->hostname) {
        if (strcmp(config->hostname, updates->hostname) != 0) {
            ESP_LOGI(TAG, "Batch update: hostname = %s", updates->hostname);
            strncpy(config->hostname, updates->hostname, sizeof(config->hostname) - 1);
            config->hostname[sizeof(config->hostname) - 1] = '\0';
            config_changed = true;
        }
    }

    if (updates->update_volume) {
        if (updates->volume >= 0.0f && updates->volume <= 1.0f && config->volume != updates->volume) {
            ESP_LOGI(TAG, "Batch update: volume = %.2f", updates->volume);
            config->volume = updates->volume;
            config_changed = true;
        }
    }
    
    if (updates->update_device_mode && config->device_mode != updates->device_mode) {
        ESP_LOGI(TAG, "Batch update: device_mode = %d", updates->device_mode);
        config->device_mode = updates->device_mode;
        config_changed = true;
    }
    
    // Handle legacy boolean fields by converting to device_mode
    if (updates->update_enable_usb_sender) {
        device_mode_t new_mode;
        if (updates->enable_usb_sender) {
            new_mode = MODE_SENDER_USB;
        } else {
            #ifdef IS_USB
            new_mode = MODE_RECEIVER_USB;
            #elif defined(IS_SPDIF)
            new_mode = MODE_RECEIVER_SPDIF;
            #else
            new_mode = MODE_RECEIVER_USB;  // Default fallback
            #endif
        }
        if (config->device_mode != new_mode) {
            ESP_LOGI(TAG, "Batch update: enable_usb_sender = %d (device_mode=%d)", updates->enable_usb_sender, new_mode);
            config->device_mode = new_mode;
            config_changed = true;
        }
    }
    
    if (updates->update_enable_spdif_sender) {
        device_mode_t new_mode;
        if (updates->enable_spdif_sender) {
            new_mode = MODE_SENDER_SPDIF;
        } else {
            #ifdef IS_USB
            new_mode = MODE_RECEIVER_USB;
            #elif defined(IS_SPDIF)
            new_mode = MODE_RECEIVER_SPDIF;
            #else
            new_mode = MODE_RECEIVER_USB;  // Default fallback
            #endif
        }
        if (config->device_mode != new_mode) {
            ESP_LOGI(TAG, "Batch update: enable_spdif_sender = %d (device_mode=%d)", updates->enable_spdif_sender, new_mode);
            config->device_mode = new_mode;
            config_changed = true;
        }
    }
    
    if (updates->update_ap_ssid && updates->ap_ssid) {
        if (strcmp(config->ap_ssid, updates->ap_ssid) != 0) {
            ESP_LOGI(TAG, "Batch update: ap_ssid = %s", updates->ap_ssid);
            strncpy(config->ap_ssid, updates->ap_ssid, WIFI_SSID_MAX_LENGTH);
            config->ap_ssid[WIFI_SSID_MAX_LENGTH] = '\0';
            config_changed = true;
        }
    }
    
    if (updates->update_ap_password && updates->ap_password) {
        if (strcmp(config->ap_password, updates->ap_password) != 0) {
            ESP_LOGI(TAG, "Batch update: ap_password");
            strncpy(config->ap_password, updates->ap_password, WIFI_PASSWORD_MAX_LENGTH);
            config->ap_password[WIFI_PASSWORD_MAX_LENGTH] = '\0';
            config_changed = true;
        }
    }
    
    if (updates->update_hide_ap_when_connected && config->hide_ap_when_connected != updates->hide_ap_when_connected) {
        ESP_LOGI(TAG, "Batch update: hide_ap_when_connected = %d", updates->hide_ap_when_connected);
        config->hide_ap_when_connected = updates->hide_ap_when_connected;
        config_changed = true;
    }
    
    bool destination_changed = false;
    if (updates->update_sender_destination_ip && updates->sender_destination_ip) {
        if (strcmp(config->sender_destination_ip, updates->sender_destination_ip) != 0) {
            ESP_LOGI(TAG, "Batch update: sender_destination_ip = %s", updates->sender_destination_ip);
            strncpy(config->sender_destination_ip, updates->sender_destination_ip, 15);
            config->sender_destination_ip[15] = '\0';
            config_changed = true;
            destination_changed = true;
        }
    }
    
    if (updates->update_sender_destination_port && config->sender_destination_port != updates->sender_destination_port) {
        ESP_LOGI(TAG, "Batch update: sender_destination_port = %d", updates->sender_destination_port);
        config->sender_destination_port = updates->sender_destination_port;
        config_changed = true;
        destination_changed = true;
    }
    
    bool buffer_size_changed = false;
    if (updates->update_initial_buffer_size && config->initial_buffer_size != updates->initial_buffer_size) {
        ESP_LOGI(TAG, "Batch update: initial_buffer_size = %d", updates->initial_buffer_size);
        config->initial_buffer_size = updates->initial_buffer_size;
        config_changed = true;
        buffer_size_changed = true;
    }
    
    if (updates->update_max_buffer_size && config->max_buffer_size != updates->max_buffer_size) {
        ESP_LOGI(TAG, "Batch update: max_buffer_size = %d", updates->max_buffer_size);
        config->max_buffer_size = updates->max_buffer_size;
        config_changed = true;
        buffer_size_changed = true;
    }
    
    if (updates->update_buffer_grow_step_size && config->buffer_grow_step_size != updates->buffer_grow_step_size) {
        ESP_LOGI(TAG, "Batch update: buffer_grow_step_size = %d", updates->buffer_grow_step_size);
        config->buffer_grow_step_size = updates->buffer_grow_step_size;
        config_changed = true;
        buffer_size_changed = true;
    }
    
    if (updates->update_max_grow_size && config->max_grow_size != updates->max_grow_size) {
        ESP_LOGI(TAG, "Batch update: max_grow_size = %d", updates->max_grow_size);
        config->max_grow_size = updates->max_grow_size;
        config_changed = true;
        buffer_size_changed = true;
    }
    
    if (updates->update_spdif_data_pin && updates->spdif_data_pin <= 39 && config->spdif_data_pin != updates->spdif_data_pin) {
        ESP_LOGI(TAG, "Batch update: spdif_data_pin = %d", updates->spdif_data_pin);
        config->spdif_data_pin = updates->spdif_data_pin;
        config_changed = true;
    }
    
    bool direct_write_changed = false;
    if (updates->update_use_direct_write && config->use_direct_write != updates->use_direct_write) {
        ESP_LOGI(TAG, "Batch update: use_direct_write = %d", updates->use_direct_write);
        config->use_direct_write = updates->use_direct_write;
        config_changed = true;
        direct_write_changed = true;
    }
    
    bool sleep_params_changed = false;
    if (updates->update_silence_threshold_ms && config->silence_threshold_ms != updates->silence_threshold_ms) {
        ESP_LOGI(TAG, "Batch update: silence_threshold_ms = %lu", updates->silence_threshold_ms);
        config->silence_threshold_ms = updates->silence_threshold_ms;
        config_changed = true;
        sleep_params_changed = true;
    }
    
    if (updates->update_network_check_interval_ms && config->network_check_interval_ms != updates->network_check_interval_ms) {
        ESP_LOGI(TAG, "Batch update: network_check_interval_ms = %lu", updates->network_check_interval_ms);
        config->network_check_interval_ms = updates->network_check_interval_ms;
        config_changed = true;
        sleep_params_changed = true;
    }
    
    if (updates->update_activity_threshold_packets && config->activity_threshold_packets != updates->activity_threshold_packets) {
        ESP_LOGI(TAG, "Batch update: activity_threshold_packets = %d", updates->activity_threshold_packets);
        config->activity_threshold_packets = updates->activity_threshold_packets;
        config_changed = true;
        sleep_params_changed = true;
    }
    
    if (updates->update_silence_amplitude_threshold && config->silence_amplitude_threshold != updates->silence_amplitude_threshold) {
        ESP_LOGI(TAG, "Batch update: silence_amplitude_threshold = %d", updates->silence_amplitude_threshold);
        config->silence_amplitude_threshold = updates->silence_amplitude_threshold;
        config_changed = true;
        sleep_params_changed = true;
    }
    
    if (updates->update_network_inactivity_timeout_ms && config->network_inactivity_timeout_ms != updates->network_inactivity_timeout_ms) {
        ESP_LOGI(TAG, "Batch update: network_inactivity_timeout_ms = %lu", updates->network_inactivity_timeout_ms);
        config->network_inactivity_timeout_ms = updates->network_inactivity_timeout_ms;
        config_changed = true;
        sleep_params_changed = true;
    }
    
    if (updates->update_enable_mdns_discovery && config->enable_mdns_discovery != updates->enable_mdns_discovery) {
        ESP_LOGI(TAG, "Batch update: enable_mdns_discovery = %d", updates->enable_mdns_discovery);
        config->enable_mdns_discovery = updates->enable_mdns_discovery;
        config_changed = true;
    }
    
    if (updates->update_discovery_interval_ms && config->discovery_interval_ms != updates->discovery_interval_ms) {
        ESP_LOGI(TAG, "Batch update: discovery_interval_ms = %lu", updates->discovery_interval_ms);
        config->discovery_interval_ms = updates->discovery_interval_ms;
        config_changed = true;
    }
    
    if (updates->update_auto_select_best_device && config->auto_select_best_device != updates->auto_select_best_device) {
        ESP_LOGI(TAG, "Batch update: auto_select_best_device = %d", updates->auto_select_best_device);
        config->auto_select_best_device = updates->auto_select_best_device;
        config_changed = true;
    }
    
    if (updates->update_setup_wizard_completed && config->setup_wizard_completed != updates->setup_wizard_completed) {
        ESP_LOGI(TAG, "Batch update: setup_wizard_completed = %d", updates->setup_wizard_completed);
        config->setup_wizard_completed = updates->setup_wizard_completed;
        config_changed = true;
    }
    
    // Save all changes at once and post event if anything changed
    if (config_changed) {
        ESP_LOGI(TAG, "Batch update: Saving configuration");
        esp_err_t ret = config_manager_save_config();
        if (ret == ESP_OK) {
            // If destination changed and we're in sender mode, update it immediately
            if (destination_changed &&
                (s_current_state == LIFECYCLE_STATE_MODE_SENDER_USB ||
                 s_current_state == LIFECYCLE_STATE_MODE_SENDER_SPDIF)) {
                ESP_LOGI(TAG, "Batch update: Updating RTP sender destination immediately");
                rtp_sender_update_destination();
            }
            // If buffer sizes changed and we're in receiver mode, reconfigure buffer
            if (buffer_size_changed &&
                (s_current_state == LIFECYCLE_STATE_MODE_RECEIVER_USB ||
                 s_current_state == LIFECYCLE_STATE_MODE_RECEIVER_SPDIF)) {
                ESP_LOGI(TAG, "Batch update: Reconfiguring buffer sizes immediately");
                buffer_size_reconfigure();
            }
            // If sleep monitoring parameters changed and monitoring is active, update cached values
            if (sleep_params_changed && monitoring_active) {
                ESP_LOGI(TAG, "Batch update: Updating active sleep monitoring parameters immediately");
                if (updates->update_silence_threshold_ms) {
                    cached_silence_threshold_ms = updates->silence_threshold_ms;
                }
                if (updates->update_network_check_interval_ms) {
                    cached_network_check_interval_ms = updates->network_check_interval_ms;
                }
                if (updates->update_activity_threshold_packets) {
                    cached_activity_threshold_packets = updates->activity_threshold_packets;
                }
                if (updates->update_silence_amplitude_threshold) {
                    cached_silence_amplitude_threshold = updates->silence_amplitude_threshold;
                }
                if (updates->update_network_inactivity_timeout_ms) {
                    cached_network_inactivity_timeout_ms = updates->network_inactivity_timeout_ms;
                }
            }
            lifecycle_manager_post_event(LIFECYCLE_EVENT_CONFIGURATION_CHANGED);
        }
        return ret;
    }
    
    return ESP_OK;
}

bool lifecycle_get_setup_wizard_completed(void) {
    app_config_t *config = config_manager_get_config();
    return config->setup_wizard_completed;
}

esp_err_t lifecycle_set_setup_wizard_completed(bool completed) {
    app_config_t *config = config_manager_get_config();
    if (config->setup_wizard_completed != completed) {
        ESP_LOGI(TAG, "Setting setup_wizard_completed to %d", completed);
        config->setup_wizard_completed = completed;
        esp_err_t ret = config_manager_save_setting("wizard_done", &completed, sizeof(completed));
        if (ret == ESP_OK) {
            lifecycle_manager_post_event(LIFECYCLE_EVENT_CONFIGURATION_CHANGED);
        }
        return ret;
    }
    return ESP_OK;
}

esp_err_t lifecycle_reset_config(void) {
    ESP_LOGI(TAG, "Resetting configuration to factory defaults");
    esp_err_t ret = config_manager_reset();
    if (ret == ESP_OK) {
        lifecycle_manager_post_event(LIFECYCLE_EVENT_CONFIGURATION_CHANGED);
    }
    return ret;
}

esp_err_t lifecycle_save_config(void) {
    ESP_LOGI(TAG, "Saving configuration to persistent storage");
    return config_manager_save_config();
}
